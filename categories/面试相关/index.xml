<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面试相关 on 八月的博客</title>
    <link>https://hiaugest.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</link>
    <description>Recent content in 面试相关 on 八月的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 26 Sep 2019 16:11:30 +0800</lastBuildDate>
    
	<atom:link href="https://hiaugest.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JAVA基础面试题汇总</title>
      <link>https://hiaugest.github.io/posts/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Thu, 26 Sep 2019 16:11:30 +0800</pubDate>
      
      <guid>https://hiaugest.github.io/posts/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>[TOC]
面试题汇总 JAVAWeb部分 1.cs与bs（面试题） cs（client/server）架构：QQ 优点：服务器稳定，安全性高 缺点：必须下载客户端，更新需要重新下载 bs（broswer/server）架构：淘宝 优点：不需下载客户端，无需更新 缺点：服务器不稳定，安全性不高
2.post与get区别（面试题） get请求： 参数提交到url地址栏上，不安全，数据量有大小限制（2kb左右） 使用情况：1.表单中默认提交2.地址栏中直接输入地址3.超链接 post请求： 参数在数据包中(http协议) ，相对安全，对提交的数据没有大小限制（） 使用情况：设置表单提交方式的时候</description>
    </item>
    
    <item>
      <title>String创建对象问题</title>
      <link>https://hiaugest.github.io/posts/String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 26 Sep 2019 16:09:25 +0800</pubDate>
      
      <guid>https://hiaugest.github.io/posts/String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98/</guid>
      <description>1.String创建对象问题 1.1 字符串常量池 定义：jvm针对字符串存储的一个特定内存区域。且里面内容都具有唯一性
1.2 创建对象单个说明 (1).String s = &amp;ldquo;abc&amp;rdquo; 在创建这个对象时,会在常量池中看有没有abc这个字符串；如果没有 此时还会在常量池中创建一个；如果有 则不创建。 (2).String s1 = &amp;ldquo;a&amp;rdquo; +&amp;ldquo;b&amp;rdquo;+&amp;ldquo;c&amp;rdquo; 在字符串常量相加时，编译器编译时产生的字节码，会把如 &amp;ldquo;a&amp;rdquo; +&amp;ldquo;b&amp;rdquo;+&amp;ldquo;c&amp;rdquo;优化为“abc”。所以只会产生一个对象 (3).</description>
    </item>
    
    <item>
      <title>枚举实现单利模式</title>
      <link>https://hiaugest.github.io/posts/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 26 Sep 2019 16:08:53 +0800</pubDate>
      
      <guid>https://hiaugest.github.io/posts/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F/</guid>
      <description>枚举实现单利模式代码 为什么不使用常规的模式实现单利 常用方式:饿汉式、懒汉式、静态内部类、双重校验锁 以上方式都存在缺陷:
1.利用反射的方式来实例化多个不同的实例 2.在序列化和反序列换的时候也会出现多个不同的实例
使用枚举实现单利的原因 单利模式的定义:保证一个类仅有一个实例，并提供一个访问它的全局访问点 枚举: 代码简单 枚举默认就是单利且线程安全 枚举单例可以自己处理序列化
使用枚举实现单利的好处: Joshua Bloch大神《Effective Java》中有提到，因为其 1.</description>
    </item>
    
    <item>
      <title>各种Map之间的区别</title>
      <link>https://hiaugest.github.io/posts/%E5%90%84%E7%A7%8DMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 26 Sep 2019 16:04:29 +0800</pubDate>
      
      <guid>https://hiaugest.github.io/posts/%E5%90%84%E7%A7%8DMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>HashMap、Hashtable、ConcurrentHashMap、TreeMap区别 相同点： 1.都是map实现类，都是键值对 2.键都不能重复，可以存储任意类型任意多个数据 3.遍历要通过keySet和entrySet方法来进行遍历 不同点 HashMap线程不安全 可以以null作为key或value 效率高，适用于在Map中插入、删除和定位元素。 （最常用） TreeMap 线程不安全 key的值不能为null，保存的记录是默认使用自然排序&amp;mdash;升序(Comprable)，也可以用比较器(Comparator)进行指定排序，所以是有序的。底层基于红黑树（一种自平衡二叉查找树）。 Hashtable线程安全 不能以null作为key或value 效率较低 同步的方法 ConcurrentHashMap 线程安全 不能以null作为key或value 效率较高 同步的代码快，提高了并发效率。</description>
    </item>
    
    <item>
      <title>遍历当前目录下的所有文件</title>
      <link>https://hiaugest.github.io/posts/%E9%81%8D%E5%8E%86%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 26 Sep 2019 16:03:02 +0800</pubDate>
      
      <guid>https://hiaugest.github.io/posts/%E9%81%8D%E5%8E%86%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/</guid>
      <description>1.遍历当前目录下的所有文件 这种遍历题一般要使用递归来解决。因为思路简单，代码不复杂，执行效率高等三大优点，但比较吃内存。
/* * 解题思路 * 设计一个方法 该方法用于找出一个文件夹中的所有文件 * 1.拿到文件夹中所有的文件对象 * 2.判断文件对象是否是文件或者文件夹 * 3.如果是文件就进行输出名字 * 4.</description>
    </item>
    
  </channel>
</rss>