<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.3" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>JAVA基础面试题汇总 | 八月的博客</title>
    <meta property="og:title" content="JAVA基础面试题汇总 - 八月的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-09-26T16:11:30&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-09-26T16:11:30&#43;08:00">
        
    <meta name="Keywords" content="八月呀,它是我八月十五日在外面捡到的流浪猫">
    <meta name="description" content="JAVA基础面试题汇总">
        
    <meta name="author" content="八月">
    <meta property="og:url" content="https://hiaugest.github.io/posts/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://hiaugest.github.io/">
                        八月的博客
                    </a>
                
                <p class="description">你好八月</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://hiaugest.github.io/">首页</a>
                    
                    <a  href="https://hiaugest.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://hiaugest.github.io/about/" title="关于我">关于我</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">JAVA基础面试题汇总</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年9月26日
                            16:11
                        </date>
                        
                        <div class="post-meta meta-category">
                            ，归类于
                            
                                <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3">面试相关</a>
                            
                                <a href="/categories/java%E5%9F%BA%E7%A1%80">java基础</a>
                            
                        </div>
                        
                        <div class="post-content">
                            

<p>[TOC]</p>

<h1 id="面试题汇总">面试题汇总</h1>

<h2 id="javaweb部分">JAVAWeb部分</h2>

<h3 id="1-cs与bs-面试题">1.cs与bs（面试题）</h3>

<p><strong>cs（client/server）架构：QQ</strong>
    优点：服务器稳定，安全性高
    缺点：必须下载客户端，更新需要重新下载
<strong>bs（broswer/server）架构：淘宝</strong>
    优点：不需下载客户端，无需更新
    缺点：服务器不稳定，安全性不高</p>

<h3 id="2-post与get区别-面试题">2.post与get区别（面试题）</h3>

<p><strong>get请求：</strong>
参数提交到url地址栏上，不安全，数据量有大小限制（2kb左右）
使用情况：1.表单中默认提交2.地址栏中直接输入地址3.超链接
<strong>post请求：</strong>
参数在数据包中(http协议) ，相对安全，对提交的数据没有大小限制（）
使用情况：设置表单提交方式的时候</p>

<h3 id="3-tcp与udp区别-面试题">3.TCP与UDP区别(面试题)</h3>

<p><strong>相同点：</strong>
    都是传输层的协议
 <strong>不同点</strong>
    <strong>TCP传输控制协议</strong>
    1.基于流的传输
    2.可靠传输协议，安全性高
    3.每一次发送数据之前都要保证双方必须都连接上了对方<strong>（双向连接，三次握手）</strong>
    4.效率低
    <strong>TCP传输控制协议</strong>
    1.基于数据报的传输
    2.不可靠传输协议，不安全
    3.传输数据的时候，不需要保证连接（无连接）
    4.效率高</p>

<h3 id="4-静态网页与动态网页的区别">4.静态网页与动态网页的区别</h3>

<p><strong>相同点</strong>
都是网页
<strong>不同点</strong>
    <strong>静态网页</strong>
    它的内容不会随时间而改变，不会随用户的操作来改变内容（html）
    <strong>动态</strong>
    内容会随时间/操作而改变（jsp，php&hellip;.）</p>

<h3 id="5-tcp三次握手-四次挥手">5.TCP三次握手，四次挥手</h3>

<p><strong>三次握手</strong>
第一次握手：
客户端向服务器发出连接请求报文，这个是三次握手中的开始。表示客户端想要和服务端建立连接；
第二次握手：
TCP服务器收到请求报文后，如果同意连接，则发出确认报文。询问客户端是否准备好；
第三次握手：
TCP客户进程收到确认后，还要向服务器给出确认。这里客户端表示我已经准备好；
<strong>四次挥手</strong>
第一次挥手：TCP发送一个FIN(结束)，用来关闭客户到服务端的连接；
第二次挥手：服务端收到这个FIN，他发回一个ACK(确认)；
第三次挥手：服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接；
第四次挥手：客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成；</p>

<h3 id="6tcp-ip如何保证可靠性-数据包有哪些数据组成">6TCP/IP如何保证可靠性，数据包有哪些数据组成？</h3>

<p>1.当客户和服务器彼此交互数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据，TCP 协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端；
2.数据包由起始行、消息头、实体内容组成，又分为请求数据包和响应数据包；
<a href="https://blog.csdn.net/Shawei_/article/details/81741817">https://blog.csdn.net/Shawei_/article/details/81741817</a></p>

<h3 id="7-什么是mvc">7.什么是MVC？</h3>

<p>1.MVC是软件设计的一种思想，这样设计出的软件开发效率高，方便维护；
2.M表示Model模型：除了控制器，所有的后台代码都可以称之为模型（业务代码，数据层代码，实体等）；
3.V表示View视图：展示给用户看的页面，例如html，Jsp等；
4.C表示Controller控制器：连接视图和Model的控制中心；</p>

<h3 id="8-tomcat能够为web项目提供什么功能">8.Tomcat能够为web项目提供什么功能？</h3>

<p>1.与Servlet程序合作处理HTTP请求；
2.管理Servlet的生命周期；
3.响应请求，跳转页面；</p>

<h3 id="9-servlet与jsp">9.Servlet与JSP</h3>

<h4 id="9-1servlet与jsp的联系和区别">9.1Servlet与Jsp的联系和区别？</h4>

<p>1.Servlet是扩展Web服务器功能的组件规范，Jsp是一种服务器端动态页面技术的组件规范；
2.Jsp就是一个Servlet，运行时先要转化为一个Servlet，同样要进过Servlet的生命周期；
3.Jsp注重数据显示，Servlet注重逻辑处理；</p>

<h4 id="9-2servlet的生命周期">9.2Servlet的生命周期？</h4>

<p>Servlet的生命周期分三个阶段，这三个阶段都是由Servlet容器调用不同的方法实现，不用我们手动调用，只是调用的时机不一样；
<strong>第一阶段：实例化和初始化即对象的创建和初始化：</strong>
(1)实质是Servlet容器去调用Servlet的无参构造去创建Servlet实例对象，然后调用init方法；
(2)默认是在第一次收到请求的时候实例化和初始化的，当使用<load-on-startup/>设置参数大于0，就会将实例化和初始化的时机提前到项目部署的时候，这样提高了运行效率（运行时不在创建对象了，因为Servlet是单例的）；
(3)只调用一次；
<strong>第二阶段：就绪或服务阶段：</strong>
(1)实质是Servlet容器去调用Servlet的service()方法处理业务；
(2)只有在容器收到请求的时候才会调用，一次请求调用一次；
<strong>第三阶段：销毁阶段：</strong>
(1)Servlet容器去调用Servlet的destroy()方法；
(2)当正常关闭服务器或软件卸载的时候才会调用；</p>

<h4 id="9-3jsp九大内置对象-隐含对象-影子对象">9.3Jsp九大内置对象（隐含对象==影子对象）</h4>

<p>输入输出对象：request、response、out
作用域对象：pageContext、session、application
Servlet对象：config、page
异常对象：exception
<strong>输出输入对象说明</strong>
request表示一次请求，可以获取请求数据包的数据；
response表示一次响应，可以获取输出流，可以设置响应类型；
out对象用于在Web浏览器内输出信息
session表示一次会话，在服务器与浏览器多次交互之前共享数据；
application 对象可将信息保存在服务器中，直到服务器关闭，而且application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的&rdquo;全局变量&rdquo;；

pageContext对象的作用是取得任何范围的绑定值，还可以获取其他内置对象，通过el表达式获取上下文路径：${pageContext.request.contextPath}
page对象代表JSP本身，只有在JSP页面内才是合法的
config对象的主要作用是取得服务器的配置信息
exception对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件
5.5.重定向和转发的联系和区别？
发送几次请求？
1.重定向：两次请求，地址栏会发生变化，不会共享同一组request和response，可以定向到外部应用；
(1)重定向是请求完成了，自动发送另一个请求
2.转发：一次请求，地址栏不会变化，可以共享同一组request和response，但不可以转发到外部应用；
(1)转发是将未完成的请求交给另一个组件去完成
5.6.CS架构与BS架构的区别？
CS架构：Client+Server客户端与服务器架构
BS架构：Broswer+Server浏览器与服务器架构
CS架构需要单独安装客户端，每次更新也需要重现更新客户端。但是稳定安全；
BS架构以刘安琪代替客户端，系统自带，不需要单独安装，也不需要更新。面向的客户人群较广，不安全，稳定性较差；
5.7.请描述Servlet的线程特性？
答：
1.第一次访问该Servlet时，服务器将创建一个该Servlet类的对象，然后将该对象放入缓存中，并调用service方法处理请求；
2.当多个客户端访问同一个Servlet时，不再创建新的对象，而是共同使用一个Servlet对象（缓存中的Servlet对象）。所以说，Servlet是多线程单实例的；
3.Servlet是单例的，但是Servlet非线程安全，所以尽量不要在Servlet中使用成员变量；
5.8.jsp中的静态include和动态include区别？
1.动态包含（动作标签jsp:include）与静态包含(jsp指令include)的区别?
(1)包含的时机不同：
(2)静态包含先把页面包含进来，再翻译成java代码（只有一个文件）；
(3)动态包含先都编译成java代码，再将内容进行包含（有多个文件）；
2.什么时候用动态包含，什么时候用静态包含?
(1)如果包含的是静态页面(html)，那么使用静态包含；
(2)如果包含的是动态网页(jsp)，那么使用动态包含；</p>

<h2 id="javase部分">JAVASE部分</h2>

<h3 id="1-线程与进程的区别-并行和并发的区别">1. 线程与进程的区别？并行和并发的区别？</h3>

<p>进程：
一个应用程序 可以看成是一大段代码  是计算机资源调度的最小单位 有自己独立的内存单元（地址空间）
线程：也被称为轻量级进程
1.一个线程可以任务是一小段代码
2.线程是一类事物，具体的一个线程就是一个对象
3.cpu调度和分派的基本单位：线程
<strong>线程与进程的区别：</strong>
1.一个程序至少有一个进程，一个进程至少有一个线程
2.线程的规划尺度小于进程，所以多线程程序的并发性高
3.地址空间/资源拥有：进程执行过程中拥有独立的内存单元，多线程的是共享内存单元，所以多线程能提高程序的运行效率。进程的资源是独立的，线程的资源是共享的。
4.执行过程：线程不能独立执行，必须依存在应用程序上（关闭进程，线程就会随之关闭。反之不一定）
<strong>并行和并发的区别并行：</strong>
并行
系统拥有一个以上的CPU时，一个CPU执行一个进程，另一个CPU执行另一个进程。两个进程同时进行又不抢占资源的方式。（<strong>人话：多个事情，同一时间点内同时发生</strong>）如在两个同学在一边听课一边笔记，是两个同学同时完成了听课和笔记这两件事情，但他们之间互不影响。
并发：
在操作系统中，是指一个时间段内有多个程序在同一处理器上都处于已启动运行到运行完成之间（<strong>人话：多个事情，在同一时间段内同时发生，同一时间点只有一个任务在进行</strong>）。如在一边听课一边记笔记，是同时完成了听课和记笔记这两件事情。</p>

<h3 id="2-线程的创建方式">2.线程的创建方式</h3>

<h4 id="继承thread">继承Thread</h4>

<p>1.创建类 继承Thread
2.覆写run方法  完成功能
3.创建对象 调用start</p>

<h4 id="实现runnable接口">实现Runnable接口</h4>

<p>1.创建一个类 实现Runnable接口
2.覆写run方法 完成功能
3.创建实现类对象
4.将实现类的对象作为参数 创建一个线程
5.调用start方法</p>

<h4 id="实现callable接口-有返回值">实现Callable接口  有返回值</h4>

<h3 id="3-线程的状态-大致">3.线程的状态（大致）</h3>

<p>征程流程：创建 &ndash;》就绪&ndash;》执行&ndash;》结束
                                                   |
                                                   &ndash;&gt;阻塞（同步阻塞 等待阻塞  其他阻塞  ）sleep</p>

<h3 id="4-解决线程安全">4.解决线程安全</h3>

<h4 id="1-同步-synchronized">1.同步 synchronized</h4>

<p>同步代码块
    监听对象：特点 唯一性
           1.this
           2.字节码
           3.其他对象（匿名对象不能  普通对象要static修饰 String有常量池的）
同步方法：
    默认监听对象是this</p>

<h4 id="2-加锁-lock">2.加锁 Lock</h4>

<p>加锁的功能更强大
<strong>总结：</strong>
同步是由jvm来维护  加锁是代码级别  需要释放锁 效率要更高一些</p>

<h3 id="5-底层基于数组-arraylist-和基于链表容器-linkedlist-了的区别">5.底层基于数组(ArrayList)和基于链表容器(LinkedList)了的区别？</h3>

<p><strong>相同点</strong>
都能够对任意类型任意个数的数据进行管理（增加修改删除查找）
<strong>不同点</strong>
底层基于数组的方式：由于有索引可以直接定位到该数据 所以修改和查找较快  而增加和删除较慢  因为涉及到数据的复制
底层基于链表的方式 增加 较快</p>

<h3 id="6-arraylist-和-linkedlist的区别">6.ArrayList 和  LinkedList的区别？</h3>

<p><strong>相同点</strong>
任意多个任意类型的数据  有序可重复
线程不安全
便利方式相同，for/foreach/迭代
 <strong>区别</strong>
ArrayList   一种底层基于数组实现：查改快，增删慢
LinkedList  一种底层基于链表实现:  查改慢，增删快
数组：  具有索引   可以根据索引直接定位到数据的位置  查询快
链表： 查找需要遍历，查找慢
数组：增加涉及扩容和复制整个数组，增删除慢
链表：直接增加在头或尾 新增效率较快</p>

<h3 id="7-hashset与treeset的区别">7.HashSet与TreeSet的区别</h3>

<p><strong>相同点：</strong>
线程不安全，无序不重复
遍历方式相同：foreach/迭代器
<strong>不同点：</strong>
去重标准：
hashSet：
1.通过hashcode和equals方法共同决定
2.hashcode让存放的数据 散列均匀分分布，减少hash碰撞
3.equals 方法 当hashcode相同的时候 调用
TreeSet：
自然排序:如果放的是对象 对象对应的类应该实现comparable接口
定制排序:自定义一个比较器 覆写comparato方法 定义比较规则</p>

<h3 id="8-list和set的区别">8.List和Set的区别</h3>

<p>相同点：
都是集合，继承了Collection接口
都可以存放任意类型，任意多个数据
不同点：
List  有序可重复
Set  无序不可重复，和map接口有关</p>

<h3 id="9-map底层">9.Map底层</h3>

<p>基于Hash表[就是一个数组],及链表接口,在Java8以后采用红黑树的方式,存储数据</p>

<h3 id="10-hashmap-hashtable-concurrenthashmap-treemap区别">10.HashMap、Hashtable、ConcurrentHashMap、TreeMap区别</h3>

<p><strong>相同点：</strong>
1.都是map实现类，都是键值对
2.键都不能重复，可以存储任意类型任意多个数据
3.遍历要通过keySet和entrySet方法来进行遍历
<strong>不同点</strong>
HashMap线程<strong>不安全</strong>   可以以null作为key或value   <strong>效率高</strong>,适用于在Map中插入、删除和定位元素。 （最常用）
TreeMap 线程<strong>不安全</strong>  key的值不能为null，保存的记录是默认使用自然排序&mdash;<strong>升序</strong>(Comprable)，也可以用比较器(Comparator)进行指定排序。底层基于<strong>红黑树</strong>（一种自平衡二叉查找树）。
Hashtable线程<strong>安全</strong>  不能以null作为key或value  效率<strong>较低</strong>   <strong>同步的方法</strong>
ConcurrentHashMap 线程<strong>安全</strong>   不能以null作为key或value 效率<strong>较高</strong> <strong>同步的代码块</strong>,<strong>提高了并发效率</strong></p>

<h4 id="解释">解释</h4>

<h5 id="1-相同点方面">1.相同点方面</h5>

<p>他们都是Map接口的实现类，所以都具有Map接口的一部分特征。而Map接口的定义就是：是<strong>键值对存在</strong>，<strong>键不能重复</strong>，键值可以为null。</p>

<h5 id="2-不同点方面">2.不同点方面</h5>

<p>线程方面：
HashMap和TreeMap都<strong>没有使用</strong>synchronized关键字来进行对内容进行修饰，所以在多线程操作的时候是<strong>不安全</strong>的。但是他们没有进行同步，所以<strong>效率</strong>会比其他的都<strong>更高</strong>。
HashTable和ConcurrentHashMap两个使用了<strong>synchronized</strong>来进行<strong>同步</strong>。但两个<strong>同步的内容</strong><strong>不相同</strong>。HashTable同步的是<strong>方法</strong>，导致了它的效率不高。ConcurrentHashMap同步的是<strong>代码块</strong>，所以效率比HashTable效率更高，但没有HashMap和TreeMap高。</p>

<h3 id="11-遍历当前目录下的所有以txt结尾的文件">11.遍历当前目录下的所有以txt结尾的文件</h3>

<pre><code class="language-java">public class FileTest {
	/*
	 * 设计一个方法  该方法用于找出一个文件夹中  以txt结尾的文件
	 * 1.拿到文件夹中所有的文件对象
	 * 2.判断文件对象是否时文件或者文件夹
	 * 3.如果时文件  此时判断文件后缀名是否是txt结尾
	 * 4.如果是  创建一个容器  将该文件对象放入容器中
	 * 
	 * */
	public static void main(String[] args) {
		File file = new File(&quot;D:/lvtest&quot;);
		List&lt;File&gt; files = getFiles(file, &quot;txt&quot;);
		System.out.println(files);

	}
	static List&lt;File&gt; getFiles(File f,String ends){
		ArrayList&lt;File&gt; list = new ArrayList&lt;File&gt;();
		//首先判断参数文件对象是为空 并且不是一个文件对象
		if(f!=null&amp;&amp;f.isDirectory()){
			File[] files = f.listFiles();
			//遍历数组 判断每个元素是否为文件或者文件夹
			if(files.length!=0){
				for (File file : files) {
					//该文件对象是一个文件
					if(file.isFile()){
						//判断文件是否是以txt结尾
						String name = file.getName();
						if(name.endsWith(ends)){
							//将满足条件的文件装入容器中
							list.add(file);
						}
					}
				}
			}
		}
		return list;
	}
}

</code></pre>

<h3 id="12-递归和迭代-循环-有什么区别">12.递归和迭代（循环）有什么区别？</h3>

<p><strong>相同点</strong>
都是对相同操作进行重复处理
/递归和迭代都是循环中的一种。
一般都需要一个明确条件作为的出口
<strong>不同点</strong>
内部实现不同，结束方式不同</p>

<pre><code>递归：递归是重复调用函数自身实现循环，遇到满足终止条件的情况时逐层返回来结束
迭代：迭代是函数内某段代码实现循环，迭代则使用计数器结束循环
</code></pre>

<p>递归和迭代的空间利用率不同</p>

<pre><code>递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。**人话：会产生压栈操作，比较消耗内存**
迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。
</code></pre>

<p>递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。</p>

<h3 id="13-jdk1-8的新特性有哪些">13.Jdk1.8的新特性有哪些</h3>

<p><strong>JKD1.8以后接口中方法可以有方法主体，但必须使用static/default修饰。</strong></p>

<pre><code>static修饰的方法： 	调用： 接口名.方法名  	不能进行覆写，不能被子接口继承
default修饰的方法：     调用：实现类名.方法名  	 能进行覆写，可以被子接口继承
</code></pre>

<p>由此引出了函数式接口&ndash;Lambda  Stream流
<strong>函数式接口</strong>
有且只有一个抽象方法，可以有其他的方法。注解@FunctionInterface表示该接口为函数式接口
<strong>Lambda表达式</strong>
1.简化代码，使代码异常简洁：可以非常优雅的把“一块代码”赋给了一个变量
2.相当于匿名内部类的简写，但不会生成字节码文件
3.语法结构  ：接口名  变量名  =  （参数类型 参数名） -&gt; {功能语句};
<strong>Stream流</strong>
添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据，让程序员写出高效率、干净、简洁的代码。
集合接口有两个方法来生成流：1.stream() − 为集合创建串行流。2.parallelStream() − 为集合创建并行流。
可以操作：数组、集合、IO流、产生器（构造方法）
常用方法：</p>

<pre><code>forEach（内部迭代的方式， 通过访问者模式(Visitor)实现。）
map 方法用于映射每个元素到对应的结果，其实就是可以对操作中的每个数字进行修改：
filtet 可以设置条件来进行过滤
distinct 去重
</code></pre>

<h3 id="14-资源文件的作用">14.资源文件的作用</h3>

<p>可以<strong>解决硬编码问题</strong>，用来管理项目的相关配置信息。<strong>降低代码耦合性</strong>
常用资源文件后缀：xml  properties(键值对)  yml</p>

<h3 id="15-反射的原理-应用场景">15.反射的原理、应用场景</h3>

<p><strong>原理：</strong>
通过字节码文件取获取类中的信息（全部：公有/私有）/程序运行的时候动态的取获取类中的信息
<strong>应用场景</strong>
1.框架底层的设计实现
2.解决硬编码的问题（增加程序的灵活性，避免将程序写死到代码里）</p>

<h3 id="16-创建对象的方式有哪些">16.创建对象的方式有哪些</h3>

<p>1.new关键字  通过调用构造器来初始化对象及实例字段的
2.反射机制  通过反射方法，调用构造器来初始化对象。（使用Class类的newInstance方法）
3.Object.clone()    clone方法创建对象并不会调用任何构造函数。 <strong>未学</strong>
4.使用反序列化    <strong>未学</strong>
5.Unsafe.allocateInstance() <strong>未学</strong></p>

<h3 id="17-你一般都使用什么方式进行数据备份-在你之前的项目中备份的周期都是多少">17.你一般都使用什么方式进行数据备份，在你之前的项目中备份的周期都是多少？</h3>

<p>备份：命令行以管理员运行cmd 不要登录mysql
mysqldump -uroot  -p密码 数据库名称&gt; 存储路径/文件名.sql
备份周期：3-5天</p>

<h3 id="18-mysql数据库中inner-join-right-join-left-join的区别">18.mysql数据库中inner join、right join、left join的区别</h3>

<p><strong>相同点：</strong>
它们都是作为表的连接（显示内链接）
<strong>不同点</strong>
inner join:取得为表与表之间得<strong>交集</strong>
right join:取得为表与表之间，以右表为主，没有就为null
left join取得为表与表之间，以左表为主，没有就为null</p>

<h3 id="19-sql语句的执行顺序">19.sql语句的执行顺序</h3>

<p>from&gt;where&gt;group by&gt;having&gt;select&gt;order by&gt;limt</p>

<h3 id="20-jdbc链接步骤">20.JDBC链接步骤</h3>

<p>jdbc： 贾琏欲执事
1.加载驱动 :  通过反射来加载驱动 Class.forName(&ldquo;com.mysql.jdbc.Driver&rdquo;);//Driver路径
2.建立连接 ：DriverManager.getConnection(&ldquo;jdbc:mysql://ip地址:端口号/数据库&rdquo;, &ldquo;用户名&rdquo;, &ldquo;密码&rdquo;);
3.获取语句（执行对象） ：连接对象.createStatement();
4.执行语句 :  execute(sql语句)
5.释放资源:  遵循先开后关</p>

<pre><code class="language-java">//1.通过反射来加载驱动
			Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
			//2.建立与数据库之间的链接
			Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/jdbctest&quot;, &quot;root&quot;, &quot;123456&quot;);
			//3.获取语句（一个执行对象）
			Statement statement = conn.createStatement();
			//4.创建一个sql语句，然后执行
			String sql = &quot;create table jdbctable(id bigint(20),name varchar(255),age int(10))&quot;;
			boolean b = statement.execute(sql);
			System.out.println(b);
			//5.关闭链接，遵循先开后关
			statement.close();
			conn.close();
</code></pre>

<h3 id="21-事务的特性有哪些">21.事务的特性有哪些</h3>

<p>定义：程序里面的一组操作，要么成功，要么失败、
特性：ACID
Atomic(原子性):一组操作不可分割
Consistency（一致性）:数据前后需要一致
Isolation（隔离性）：并发编程的时候，多个线程之间的操作互不影响
Durability（持久性）：将内存中的数据持久化磁盘</p>

<h3 id="22-preparedstatement和statement的区别">22. PreparedStatement和Statement的区别</h3>

<p><strong>不同点</strong>
PreparedStatement是预编译/预处理语句，效率更高
    1.是statement的接口
    2.PreparedStatement解决字符串的拼接问题
    3.安全性更高，PreparedStatement解决sql注入问题
    4.PreparedStatement效率更高
    5.代码的可读性和可维护性。 更好
Statement
    1.适用于只使用一次的语句，内存消耗很小</p>

<h3 id="21-使用连接池和不使用连接池的区别-未答完整">21.使用连接池和不使用连接池的区别//未答完整</h3>

<p>从代码上:
<strong>不使用连接池</strong>: Conenction对象由DriverManager获取.
  Connection conn = DriverManager.getConnection(url,username,password);
<strong>使用连接池</strong>:(只有一个不同点，现在的连接需要从DataSource里面拿，DataSource需要从数据库拿，
所以我们需要把用户名和密码给连接池，连接池帮我们从数据库拿连接)
如何创建DataSource对象,如何在DataSource中设置url,账号,密码.
  Connection conn = DataSource对象.getConnection();</p>

<h2 id="面向对象">面向对象</h2>

<h3 id="1-什么是面向对象">1.什么是面向对象</h3>

<p>是一种编程思想,在java中万物皆可是对象；
在java中主要通过类和对象来体现;
        类：从不同维度去描述某一类事物  不会具体指代某个个体  相当于一个模板
        对象：该分类中某一个具体的个体  相当于就是复制了一份模板 可以填写具体的数据信息
比如 人可以从肤色 国籍 身高。。。。去描述人类  类<br />
        具体的某个人 比如 Lucy 肤白 美国  180  就是对象</p>

<h3 id="2-this-static-super-final关键字">2.this static super final关键字</h3>

<h4 id="this"><strong>this</strong></h4>

<p>定义:当前的方法被谁调用 this就指向谁的地址
作用：
    1.解决成员变量与局部变量的二义性
    2.作为参数传递
    3.作为返回值返回
    4.调用构造方法 必须放在构造方法中的第一句
注意：不能static修饰的方法中使用this</p>

<h4 id="static"><strong>static</strong></h4>

<p>1.概念 : static关键字,静态的修饰符:类级别的修饰符
2.static修饰的内容：
    字段:该字段被该类的所有对象共享
    普通方法:工具方法,通过类名.方法名使用
3.static 静态加载:会在<strong>加载的时候初始化执行代码</strong>
4.static类级别的<strong>修饰符理解</strong>
    (1)static修饰的字段:应该通过类名.字段名访问
    (2)static修饰的字段:应该通过类名.方法,该字段被该类的所有对象共享
5.<strong>对象级别</strong>
    非static修饰的字段:对象名.字段名
    非static修饰的字段及方法,当创建对象时候,独属于每每一个对象,每有被该类的所有对象共享
6.<strong>静态上下文不予许访问非静态的变量及方法</strong>
   非静态上下文,可以访问静态上下文:   可以
<strong>7可以修饰：</strong><br />
普通方法  成员变量  内部类</p>

<h4 id="super"><strong>super</strong></h4>

<p>定义：指向父类的地址 在子类中可以看成是父类的对象
作用：<br />
   1.可以调用父类的构造方法（只能在子类中的构造方法中使用 并且必须在第一句）
   2.可以调用父类的普通方法（哪怕子类中有覆写的方法 还是会调用父类）
   3.<strong>特殊用途</strong>：创建子类对象的时候会隐式的调用父类无参的构造方法 如果有显示的调用父类的构造方法 隐式的调用就不再存在了
<strong>分析</strong>
1.<strong>为什么javaBeanb必须提供一个无参数的构造方法</strong> :
    特殊用途已做解释
2.<strong>为什么可以用到父类的私有的字段</strong>：
    通过get（）set（）方法存值取值因为子类的构造方法第一句，一定会用到父类的构造方法，意味着象this,将父类的对象与    子类构造方法，创建的对象，打包在了一起
3.<strong>继承</strong>：<strong>为什么能够继承到父类的东西因为</strong>：
    子类构造方法，一定会用到父类的构造方法！</p>

<h4 id="final"><strong>final</strong></h4>

<p>定义：最终的 关键字 修饰符
作用：
     成员变量：必须赋予初始值
     局部变量:一旦赋值不能更改
     普通方法:不能被覆写
     外部类：不能被继承
注意：不能修饰:构造方法
使用情况： final 主要和static一起使用 对全局常量的修饰</p>

<h3 id="3-说一说面向对象的三大特征">3.说一说面向对象的三大特征</h3>

<h4 id="封装"><strong>封装</strong></h4>

<p>定义：将一些属性隐藏起来 提高安全性 通过私有化字段 然后对外提供公共可访问的方法来实现
标准的javabean：
    1.私有化字段（private修饰字段）
    2.提供getter和setter方法
    3.提供一个无参的构造方法</p>

<h4 id="继承"><strong>继承</strong></h4>

<p>定义：将一些共有属性抽取出来成为父类，然后其他继承该类 可以获取到共有的一些属性和方法
可以继承：成员变量 普通方法      不可继承：构造方法
特点：
    1.单继承
    2.多重继承
    3.如果一个类没有显示的继承关系 那么隐式Object
作用：提高复用性</p>

<h4 id="多态"><strong>多态</strong></h4>

<p>定义：编译和运行时类型不一致的情况 称为多态
特点：
     1.编译看左边 运行看右边  编译只看类型
     2.如果由static修饰 运行的时候还是看编译的类型
作用：屏蔽了子类之间的实现差异</p>

<h3 id="4-object类中有那些方法可以被覆写-有什么意义">4.Object类中有那些方法可以被覆写？有什么意义？</h3>

<h4 id="覆写tostring"><strong>覆写toString</strong></h4>

<p>需要打印对象描述的时候，原方法不符合我们打印对象描叙的需求，覆写后可以准确打印对象的描述。</p>

<h4 id="覆写equals"><strong>覆写equals</strong></h4>

<p>需要比较两个对象是否相等的时候，Object类中的equals方法不符合我们对于一个类对象比较的需求。覆写后可以进行比较对象之间的内容
<strong>finalize()</strong>
垃圾回收机制回收对象的时候会主动调用的方法
<strong>hashCode + equals</strong>
验证对象放入HashSet集合中,判断元素是否重复</p>

<h3 id="5-和-equals区别">5.== 和 equals区别</h3>

<p><strong>相同</strong>
a 传统的理解一般都是数字值是否相等;
b 在程序中任何东西都是数据,都会比较是否相等[ 对象 ]
<strong>不同点</strong>
没有覆写equals之前的区别:<br />
两个比较的都是引用数据类型变量的地址值
==可以进行基本数据类型变量值的比较，equals不行
覆写后的区别：
equals比较的是对象的属性值是否相等<br />
==比较的是对象的地址值</p>

<h3 id="6-单例模式">6.单例模式</h3>

<p><strong>实现单例模式：</strong>
        1.私有化构造方法
        2.准备一个对象
        3.对外提供一个公共静态的方法返回准备的对象
<strong>作用</strong>
        1.控制资源的使用，通过线程同步来控制资源的并发访问
        2.控制实例产生的数量，达到节约资源
        3.作为同学媒介，数据共享
<strong>使用场景</strong>
        1.只需要一个对象的时候
        2.工具类多采用单例模式
        3.jdbc连接</p>

<h4 id="懒汉模式-被动-具有线程安全问题"><strong>懒汉模式（被动、具有线程安全问题）</strong></h4>

<pre><code class="language-java">class LazyModel{
	//私有化构造方法
	private LazyModel(){}
	private static LazyModel instance;
	public static LazyModel getInstance(){
		if(instance==null){
		    instance = new LazyModel();
		}
		return instance;
	}
}
</code></pre>

<h4 id="饿汉模式-主动"><strong>饿汉模式（主动）</strong></h4>

<pre><code class="language-java">class HungryModel{
	//私有化构造方法
	private HungryModel(){}
	//事先创建好对象
	private static HungryModel intansce;
    static{
		intansce = new HungryModel();
		//更多语句
	}
	//对外提供一个公共可访问的静态方法
	public static  HungryModel getIns(){
		return intansce;
	}
}
</code></pre>

<h3 id="7-抽象类与接口的区别">7.抽象类与接口的区别</h3>

<p><strong>相同点：</strong>
都只有覆写过抽象方法后才能实例化
都不能进行实例化，都支持多态
<strong>区别：</strong>
1.抽象类是本质一个类，接口是一个与类类似的一种接口
2.类是单继承，多重继承 接口可以被接口多继承，多重继承，接口只能被实现，可以多实现
3.类中有构造方法但不能实例，接口中没有构造方法
4.接口中的字段默认由public static final修饰  方法默认由public abstract修饰。java1.8之后才允许由普通方法
5.抽象类一般是作为模板类 接口是可以作为模板类也可以定义全局变量</p>

<h3 id="8-string会创建几个对象问题">8.String会创建几个对象问题</h3>

<p>关于这一部分的CSDN文章链接：
原文：<a href="https://blog.csdn.net/ChengHuanHuaning/article/details/97523846">https://blog.csdn.net/ChengHuanHuaning/article/details/97523846</a></p>

<pre><code class="language-java">1.String s1 = &quot;a&quot; +&quot;b&quot;+&quot;c&quot;;   //1个对象
2. String s2 = &quot;a&quot;;		    //1个对象
  String s3= s2 +&quot;bc&quot;;   	//3个对象
3.String s4 = new String(&quot;你&quot;) + s2 + &quot;b&quot;;  	  //5个对象
-----------------下面代码与上面代码没有联系-------------------------------
1.String s6 = &quot;a&quot;;
2.String s7= &quot;b&quot; +&quot;c&quot; + s6;  	 //3个对象
3.String s8= s6 + &quot;d&quot; +&quot;f&quot; ;	 //4个对象
4.String s9= &quot;ab&quot; + &quot;cd&quot; + s6 + &quot;b&quot; +&quot;c&quot;   //5个对象

</code></pre>

<p>下面是这些编译过后的代码，来帮助理解</p>

<pre><code class="language-java">1.String s1 = &quot;abc&quot;;
2.String s2 = &quot;a&quot;;
  String s3 = s2 + &quot;bc&quot;;
3.String s4 = new String(&quot;你&quot;) + s2 + &quot;b&quot;;
-----------------下面代码与上面代码没有联系-------------------------------
1.String s6 = &quot;a&quot;;
2.String s7 = &quot;bc&quot; + s6;
3.String s8 = s6 + &quot;b&quot; + &quot;c&quot;;
4.String s9= &quot;abcd&quot; + s6 + &quot;b&quot; +&quot;c&quot;
--------------------- 

</code></pre>

<h3 id="9-代码块">9.代码块</h3>

<p>定义：{ }里面的内容
分类：
<strong>局部代码块</strong>：<br />
1.执行无影响
2.作用域分割，希望某变量在一定的区域使用
<strong>静态代码块</strong>：<br />
1.写在类中，使用static修饰
2.优于主方法执行，一般用于赋初始值操作
<strong>构造代码块：</strong><br />
1.写在类中，无static修饰
2.每个构造器中都会复制一份</p>

<h2 id="基础方面">基础方面</h2>

<h3 id="1-java跨平台原理">1.java跨平台原理</h3>

<p>通过在不同的平台上安装不同的jvm虚拟机，jvm虚拟机可以运行编译后的字节码文件。从而达到跨平台原理。</p>

<h3 id="2-jdk-jre-jvm三者之间的关系">2. jdk  jre  jvm三者之间的关系？</h3>

<p>jvm：运行字节码文件
jre：包含jvm以及一些核心类库
jdk：包含jre以及一些基础类库和一些工具 比如（java javac  javadoc）</p>

<h3 id="3-值传递和引用传递">3.值传递和引用传递</h3>

<p>基本数据类型在作为参数传递的时候 传递的是值本身
引用数据类型在作为参数传递的时候 传递的是引用地址  String除外</p>

<h3 id="4-说一说-与-和-或-的使用">4.说一说 &amp;&amp;(与)和||(或) 的使用</h3>

<p>逻辑与逻辑或 : 主要用于组合条件判断
特点:
    ①运算符两边类型都为boolean类型
    ②运算符运算结果也为boolean类型
    ③<strong>具有短路行为</strong>
<strong>&amp;&amp;</strong><br />
    ①两边结果为true  结果为true
    ②如果前面为false  后边不会运算
<strong>||</strong><br />
    ①只要有一边的结果为true 结果为true
    ②如果前面为true   后面不会运算
判断3  是否小于5 并且 大于1;
    ①3<5 &&  3> 1
判断3 是否大于5 或者小于 1
    ①3&gt;5|| 3&lt;1</p>

                        </div>

                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="/tags/%E6%80%BB%E7%BB%93">总结</a></li>
                                
                                <li><a href="/tags/java%E9%9D%A2%E8%AF%95%E9%A2%98">java面试题</a></li>
                                
                            </ul>
                            
                        </div>
                        
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://hiaugest.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hiaugest.github.io/posts/%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E4%B8%AD/" title="HUGO  将个人博客部署到GitHub中">HUGO  将个人博客部署到GitHub中</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" title="JAVA基础面试题汇总">JAVA基础面试题汇总</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/HUGO-4%E5%8F%A5%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="HUGO  4句代码让你搭建个人博客">HUGO  4句代码让你搭建个人博客</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98/" title="String创建对象问题">String创建对象问题</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F/" title="枚举实现单利模式">枚举实现单利模式</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/JAVAEE-Servlet/" title="JAVAEE Servlet">JAVAEE Servlet</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/JDBC%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BA%8B%E7%89%A9%E4%BB%8B%E7%BB%8D/" title="JDBC连接与事物介绍">JDBC连接与事物介绍</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/JAVA%E5%8F%8D%E5%B0%84%E4%B8%8E%E9%85%8D%E7%BD%AEXML%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" title="JAVA反射与配置XML文件操作">JAVA反射与配置XML文件操作</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/IO%E6%B5%81%E6%80%BB%E7%BB%93/" title="IO流总结">IO流总结</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/posts/java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="Java8  Lambda表达式">Java8  Lambda表达式</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hiaugest.github.io/categories/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">hugo搭建博客(2)</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/categories/java%E5%9F%BA%E7%A1%80/">java基础(9)</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结(4)</a>
    </li>
    
    <li>
        <a href="https://hiaugest.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关(5)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://hiaugest.github.io/tags/IO%E6%B5%81/">IO流</a>
    
    <a href="https://hiaugest.github.io/tags/JDBC/">JDBC</a>
    
    <a href="https://hiaugest.github.io/tags/Lambda/">Lambda</a>
    
    <a href="https://hiaugest.github.io/tags/Map/">Map</a>
    
    <a href="https://hiaugest.github.io/tags/hugo/">hugo</a>
    
    <a href="https://hiaugest.github.io/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/">java8新特性</a>
    
    <a href="https://hiaugest.github.io/tags/java%E5%9F%BA%E7%A1%80/">java基础</a>
    
    <a href="https://hiaugest.github.io/tags/java%E9%9D%A2%E8%AF%95/">java面试</a>
    
    <a href="https://hiaugest.github.io/tags/java%E9%9D%A2%E8%AF%95%E9%A2%98/">java面试题</a>
    
    <a href="https://hiaugest.github.io/tags/servlet/">servlet</a>
    
    <a href="https://hiaugest.github.io/tags/xml%E6%96%87%E4%BB%B6/">xml文件</a>
    
    <a href="https://hiaugest.github.io/tags/%E5%8F%8D%E5%B0%84/">反射</a>
    
    <a href="https://hiaugest.github.io/tags/%E6%80%BB%E7%BB%93/">总结</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" title="Android Gradle权威指南">Android Gradle权威指南</a>
        </li>
        
        <li>
            <a target="_blank" href="http://mirrors.flysnow.org/" title="常用开发工具CDN镜像">常用开发工具CDN镜像</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://hiaugest.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://hiaugest.github.io/">八月的博客 By 八月</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        
        (function () {
            $("pre code").parent().addClass("line-numbers")
        }());

        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'GA ID', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>